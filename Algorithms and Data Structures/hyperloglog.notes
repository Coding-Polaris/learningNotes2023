Hyper(log(log()))

Adapted from Victor Sanchez Portella's video "The Algorithm with the Best Name - HyperLogLog Explained"

https://www.youtube.com/watch?v=2PlrMCiUN_s

1. Hyperloglog is a count approximator

2. A use case would be for unique website visitors

3. Even if we only use one bit per visitor, that's still a gig of RAM or storage for a lot of visitors simply for a trivial feature

4. log(log()) grows very slowly, which means that it tends to top out in memory usage in practical situations at 2KB

5. However, it is only an *approximate*, not exact count

6. Examples of practical uses:

    1. Reddit - post visitors

    2. Facebook in databases

    3. Google - internal tasks

7. HLL fundamentally uses randomness to work

8. Uses what's called a hash function

    1. Converts each visitor's id to a random sequence of bits (0s + 1s), a binary string

    2. Because the random generator isn't changing, same visitor id produces (theoretically) the same output

    3. This doesn't perfectly produce unique output from every string, hence it is approximate

9. How do we count unique random strings?

    1. Example: Flip a coin

        1. If heads, flip again. If tails, start over

        2. It takes quite a lot of luck to get a long string of only heads

        3. We take the inverse of the probability of however many heads we see
        as a close guess of how many times the game has been played to get that
        result

        4. In other words - 3 heads = (0.5)^3 probability, = player maybe tried 16 times to get that result

        5. So attempts = 2^(L+1) where L is the number of times a result of 50% probability is seen

    2. How does this relate to unique user count approximation?

        1. Bit strings are zeros and ones

        2. The probability of either number is one in two

        3. In this case we'll think of zeros as heads

        4. Therefore, the chances a user has a certain number of zeros
        at the start of their name gets much lower with the length of the
        zero-string

        5. So... We use the *maximum number of zeros* we have seen to guess
        about how many users we have seen.

            zero = 2
            one = 4
            two = 8

            etc.

    3. How does this pertain to *unique* users? Since the bit hash made by
    a user's id stays the same, we can afford to only be interested in the max
    number of zeros generated by random visits

10. Memory calculations

    1. Suppose we want enough memory to count to some number M

    2. If we know that 2^(L+1) will never be greater than M,

    3. L <= log(M)

    4. 