1. Everything in Part 1 was (mostly) hard-coded into components, except where I skipped ahead and used props :)

2. This section's project is a clone of the airbnb experiences page

3. While the top is probably hard-coded, the bottom is probably dynamically pulled down and generated by React from the back-end DB

4. Figma -> Top of page -> Duplicate to drafts

5. What to learn in this module

    1. Nail down *props*, the concept + syntax

        1. Used to create reusable/composable components

    2. How to create React components from an array (did I do this already with `.map`?)

        1. It's implied this array contains data that is regularly updated

            1. can be automatically changed or changed with page refresh

            2. doesn't need direct developer input

6. Section 2 - Project Setup - Navbar

    1. Mostly a review of previous section; custom components

    2. Navbar; photo grid; description section ("hero component?")

    3. Task: Write the navbar

        1. projectDemos/src/components/Experiences/

        2. projectDemos/stylesheets/experiences.scss

        3. I created and styled a container for the experiences module, and also for the navbar

        4. I originally made the nav a div and picked padding from the Figma file; came out properly

        5. Mistakes: 

            1. Use <nav> instead of <div> for more expressivity

            2. I didn't add `box-sizing: border-box;` directly on my nav, so it rendered a bit bigger than I intended

        5. Didn't need to manually size logo because of how it downloaded from Figma

        6. Bob uses `display: flex;` here to confine the image, but I won't do this unless we add more elements to it - padding works well enough here

        7. Maybe I should be using `rgba(r, g, b, alpha)` instead of hex codes lol

    4. Task: Build the "hero" component

        1. Includes a photo grid, header, and description paragraph

        2. Bob somehow managed to have a rasterized export option for the photo grid so that I don't need to manually configure the grid

        3. Because I've been learning grid and need to challenge myself, I'm going to download each of the images and try to manually place them with CSS grid

        4. The header and description are pretty straightforward, setting margins from the Figma

        5. The first tricky part is loading in all nine images.

            1. Instead of nine `import` statements, I wrote an array to dynamically pass an image filename to...

            2. ...A component that uses an async (admittedly ChatGPT-generated) to load the local image with that filename

            3. I borrowed this approach from the previous solo project, which was a brief row of social media icons

        6. This ended up working; now it's time to arrange them in a grid.

            1. Copying from my Discord post:

                1. Set a two-row grid with five columns.

                    2.  One day I'll know how this works/how to do this properly.
                
                2. `grid-row: span 2;` the first element to let it sit within its own column, starting the next row from column 2.

                3. Set positive margins on the top for the stagger effect, and manual negative margins on the bottom for the clustering effect.

                4. Ideally there would be some way to get the second row to simply hug the first, but I'm not aware of how to do that

                    1. any approach where I dictate rows of like 14 pixels would be arguably even jankier

    5. Task: Build the experience card

        1. Card features (that I can see)

            1. A picture with a status/property tag at its top left

            2. A score that is an average of many scores;

            3. The number of reviews contributing to the score;

            4. The location of the experience

            5. The title

            6. The starting price per person

        2. Since we don't have a data source, the first card will be hard-coded

            1. Made a status badge with absolute positioning relative to the parent, the card.

                1. This required me to set a `position: relative` on the parent and `position: absolute` on the child.

                2. Both the card's image and the badge have a border-radius, so I tweaked those to look correct after sizing the image.

            2. Pretty straightforward image imports and formatting the appropriate sections

            3. Only significant difference I see here is that I should maybe be using <p> instead of <div> at some points, but functionally the same

            4. Well, that and I'm overusing Components probably

6. Section 3 - Accessibility Audit

    1. Make sure to use semantic, or appropriately named, elements.

    2. Headers for larger text and titles.

    3. Don't think about what the ultimate design or style looks like

        1. Instead use the element type closest to the semantic category of the content

    4. In CSS, don't select elements if you have more than one page. Select classes instead.

    5. For accessibility, set rem values instead of pixels for fonts.

    6. Add alt texts to images for the blind.

    7. If there's no obvious alt text, at least describe what role the image is playing in <alt>.

7. Section 4 - Issues with hard-coding

    1. SHOCKING: Repeated elements are often filled in with database data, without having to manually change HTML to contain that info

8. Section 5 - Props basics

    1. As we know, some elements are useless without attributes -- like <a> without `href` and <img> without `src`

    2. Likewise, functions are often useless without arguments/parameters

    3. Props, then, are the arguments accepted by the functions that return JSX

    4. props can be used to populate the content of JSX in much the way arguments populate the content of normal JavaScript functions

        1. for example, let's say we have a JSX component called ImageContainer

        2. pass props as an argument to ImageContainer

        3. props is just an object with keys and values.

        4. JSX accepts JavaScript written directly inside of two curly braces `{}` to write the return value of running the code directly into the JSX,
        as in <p>Hello {firstName} {lastName}</p>. 

        4. you could use {props.imageSrc} to define an `<img>`'s src in the JSX, like <img src={props.imageSrc}>

        5. Now you have a dynamic, reusable component by simply changing what goes into the props passed to ImageComponent

        6. To avoid mixing up logic and view code too much:

            1. Run JS to define variables or constants in the opening of your component's JS function, well before the `return` statement that has your JSX

            2. Simply plug those values into the JSX

    5. Bob's giving us a challenge here with Cat Contact Cards (that I'm not doing, at least not yet):

        1. Move plain HTML to a cat contact card JSX component and render it four times

        2. Think about why this by itself is a bad approach

            1. It's still hard-coded HTML, so the information doesn't change

            2. He didn't specify whether to use a loop, so the number of instances is also hard-coded

    6. As I thought, he does a callback to his arbitrary function addTwoNumbers

        1. Passing attributes to a JSX component populates the props object

        2. The attributes can have almost any name

        2. This populates the keys of the `props` object 

    7. The "real" challenge

        1. Manually write props into each of the components 

        2. Again, not putting this here

        3. Instead, when it comes time to write this:

            1. I'm going to write the info into a data structure, then

            1. map each element's values to the correct `props` values for the corresponding
            indexed react component

        4. Basically, `catsArray.each()...` for an array of objects containing cat data

9. Props part 4

    1. Bob was nice enough to console.log the props he passed into each contact card

    2. This gives me enough to write the data structure code very easily:

        const cats = [
            {
                image: "./images/mr-whiskerson.png",
                name: "Mr. Whiskerson",
                phone: "(212) 555-1234",
                email: "mr.whiskaz@catnap.meow"
            },
            {
                img: "./images/fluffykins.png",
                name: "Fluffykins",
                phone: "(212) 555-2345",
                email: "fluff@me.com"
            },
            {
                img: "./images/felix.png",
                name: "Felix",
                phone: "(212) 555-4567",
                email: "thecat@hotmail.com"
            },
            {
                img: "./images/pumpkin.png",
                name: "Pumpkin",
                phone: "(0800) CAT KING",
                email: "pumpkin@scrimba.com"
            }
        ]

    3. The rest is just:

        1. import cats in the same js file that i'll be using `.map` on it

        2. use `.map` to pass each individual cat from App to Contact and mark the key of a Contact element written for it

        3. fill in the points where the data for each cat should go

        4. then they should map in order

    4. Tested this on Scrimba, it works, obviously i lost my code without a fork

    5. Bob got me by deliberately misnaming the image property in cats

10. Quiz time:

    1. The quiz:

        1. What do props help us accomplish?

            Help use re-use components without hard-coding their information

        2. How do you pass a prop into a component?

            as an attribute of the component similar to attributes in normal HTML elements

        3. Can I pass a custom prop (e.g. `blahblahblah={true}`) to a native
           DOM element? (e.g. <div blahblahblah={true}>) Why or why not?
           
           No. Native elements don't support these attributes, nor the curly brace interpolation syntax

        4. How do I receive props in a component?

            function Navbar() { // <-- put props here
                return (
                    <header>
                        ... // <-- use {props.<attribute name>} here...
                    </header>
                )
            }

            Add props (or anything, really) as the first argument, then reference it in the JSX below using {}.

        5. What data type is `props` when the component receives it?

            A JavaScript Object

    2. How'd I do?

        1. Correct, pretty much

        2. Correct

        3. Correct -- Just remember that JSX is an Object that *describes* what a native DOM element should look like

        4. It just asked for receive, not how to use!

        5. Correct

11. Destructuring props

    1. Suppose you have this object:

        const person = {
            img: "./images/mr-whiskerson.png",
            name: "Mr. Whiskerson",
            phone: "(800) 555-1234",
            email: "mr.whiskaz@catnap.meow"
        }

    2. if you write:

        const {img, name} = person

    3. You declare two new constants, img and name, that correspond to the keys with the same names within the person object

        1. So, img === person.img and name === person.name

    4. Why do this now?

        1. It's an easier way of making a bunch of variables directly from `props` instead of writing them all out individually.

        2. You don't even have to declare const in your components

        3. just write {<desired key names>} directly into the arguments of the component (e.g. {img name phone})

    5. You can also rename the new variable, say from img to image, by using the syntax `const {image: img} = person`

    6. Challenge: Fix bugs caused by using props the old way in the JSX but with destructuring in the args

        1. I do this by just removing all direct references to props

    7. Bob believes using props and referencing its keys is more expressive

        1. But teaches us both, since both methods are used in React development

12. Section - Props practice

    1. I'll take a moment to do the Cat Contact and Joke examples here

        1. Concepts learned besides props and interpolation practice:

            - CSS blur, transitions, and stroke/emulating stroke

            - Learning that transitions don't work if you remove the classes that allow them (attempting to blur/unblur punchlines)

            - More grid and flex practice

            - Centering, positioning, and margins

            - Using utility classes and minimizing specific styling

    2. And done. Probably time to break the project folder out into its own repo.

    3. I didn't know about the horizontal rule <hr> element. Interesting!

    4. Bob teaching proper conditional rendering:

        1. Surround JSX in curly braces.

        2. Use &&. No need to define a variable to store the condition, like I did when I practiced.

        3. Remember truthy/falsy to avoid weird behavior.

13. Section - Non-string props

    1. Bob has a question: How do we pass in non-string props?

    2. I think it's just sticking them in curly braces in attribute= in the JSX, as I've been doing

    3. This is in contrast to traditional HTML quotes around each attribute.

    4. And I was right because I'm a genius!

    5. You can pass arrays, pretty much anything as long as it's a valid JavaScript expression

        1. The expression's return value is what comes out of curly braces.

14. Section - Project: Pass props to card component

    1. Pretty sure I've done this already, but I'm going to compare how I did it to how Bob wants us to do it.

    2. Remember that template strings (or where you can interpolate with ${}) are used in JSX like:

        1. <element attr={`plain text ${expressionToInterpolate}`}>

15. Section: Review - array.map()

    1. Challenges:

        //Challenge 1:
        //Given an array of numbers, return an array of each number, squared

        const nums = [1, 2, 3, 4, 5]
        // -->       [1, 4, 9, 16, 25]
        // naive answer
        const squaredNums = nums.map(function(num) {
            return(num ** 2)
        })

        // feedback
        he did num * num. tomato tomato

        ===
        // Challenge 2:
        // Given an array of strings, return an array where 
        // the first letter of each string is capitalized

        const names = ["alice", "bob", "charlie", "danielle"]
        // -->        ["Alice", "Bob", "Charlie", "Danielle"]
        // naive answer

        const capitalizedNames = names.map(function(name) {
            return(`${name[0].toUpperCase()}${name.slice(1, name.length)}`)
        })

        // feedback
        probably would have been better to just use string concatenation and slice(1)
        i didnt know that slice(1) is just the start index to the end

        
        // Challenge 3:
        // Given an array of strings, return an array of strings that wraps each
        // of the original strings in an HTML-like <p></p> tag.

        // E.g. given: ["Bulbasaur", "Charmander", "Squirtle"]
        // return: ["<p>Bulbasaur</p>", "<p>Charmander</p>", "<p>Squirtle</p>"]

        const pokemon = ["Bulbasaur", "Charmander", "Squirtle"]
        // -->          ["<p>Bulbasaur</p>", "<p>Charmander</p>", "<p>Squirtle</p>"]
        // naive answer

        const pPokemon = pokemon.map(function(monName) {return(`<p>${monName}</p>`)})

        // feedback
        looks fine

16. Section - React renders arrays

    1. Recall that JSX returns a JavaScript object

    2. Arrays tend to be arrays of objects due to the complexity of data

    3. Before telling us how to do it, Bob wants us to experiment with an array of strings
    to try and get it to spit out elements.

        1. I ended up writing JSX directly into the array in the Scrim. It works as I expected.

17. Section - Mapping components

    1. As long as I use `export default`, I don't need to name my data when `export`ing it to 
    an array or object that i'll be `import`ing in another file.

    2. Bob thinks of curly braces as "leaving" JSX and "entering" JavaScript

    3. Challenge: render the joke elements using an array of joke objects, `.map`, and JSX

        Did something mostly like this in my interpretation of the project already, but did it again for this section.

18. Quiz - .map

    1. What does the `.map()` array method do?

        1. Student: Iterates over an array, with each iteration returning a new value (usually based on using logic on the current element),
        then returns a new array with that return value in place of the original value. (The result is "mapped" to each element, so to speak.)

        2. Feedback: Correct, just remember that it's a new array being returned.

    2. What do we usually use `.map()` for in React?

        1. Student: Return a series of components constructed from arrays of data

        2. Feedback: YEP

    3. Why is using `.map()` better than just creating the components
    manually by typing them out?

        1. Saves a lot of time in writing and maintenance, leaves less room for error, and allows for dynamic data to be used

        2. Feedback: First two points are basically just DRY, but all correct. Instructor calls dynamic data "self-sustaining".

19. Project - Map experiences data into components

    1. I probably should not have jumped ahead here and done the project before this,
    but it looks like the changes between my implementation and this challenge's starting point are fairly small.

    2. I put map in the middle of my JSX, but it's probably better to follow Bob's approach and do the setup logic outside of the view code.

    3. `overflow-x: auto;` will give you a nice scrolling function when the container's native width is exceeded.

20. Skimming/skipping a bunch of stuff i already did:

    1. Handling and storing conditional stuff outside of the JSX is good

        1. Like for whether we want to display "online" or "sold out" for a badge that can say either of those things

    2. Pass in the entire data structure and extract inside the component, rather than setting each attr to each value

21. Project: Spread object as props

    1. Using `...<object variable name>` will map all the keys and values to variables and values in `props`.

    2. Example:

        const item = { letter: "a", number: 3 }
        <Card {item} />

        // Card.js
        function Card(props) {
            console.log(props.letter) // => "a"
            console.log(props.number) // => 3
        }

    3. Bob's prefers passing objects in, intact

        1. This keeps the structure and names of the data explicit

        2. Keeping you from needing to recheck the origin data

        3. And therefore being better for maintenance

    